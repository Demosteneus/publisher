<!DOCTYPE html>
<html>
<head>
    <title>Handbuch Publisher</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link rel="alternate" type="application/atom+xml"  title="Liste der Änderungen speedata Publisher (de)"  href="../changes-de.xml" />
    <link rel="stylesheet" href="../assets/css/normal.css" type="text/css" />
    <link rel="stylesheet" href="../assets/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../assets/css/colorbox.css" type="text/css" />
    <script src="../assets/js/jquery.min.js" ></script>
    <script src="../assets/js/jquery.colorbox-min.js" ></script>
    <script>
      $(document).ready(function(){
         $(".figure").colorbox({ rel: 'group1', opacity:0.5 });
      });
    </script>
</head>
<body>
<div id="logo"><a href="../index-de.html"><img src="../assets/images/publisher_logo.png" alt="Start page"></a></div>
<div class="">
<h1>XPath Ausdrücke</h1>

<p>Der Publisher akzeptiert in den den entsprechend markierten Attributen
(zumeist <code>auswahl</code> und <code>bedingung</code>) XPath Ausdrücke. In allen anderen
Attributen kann durch die geschweiften Klammern (<code>{</code> und <code>}</code>) ein XPath
Ausdruck erzwungen werden. In diesem Beispiel werden im Attribut
<code>breite</code> und im Element <code>Wert</code> die Werte dynamisch erzeugt, d.h. für die
Angabe der Breite wird auf den Inhalt der Variablen <code>breite</code>
zurückgegriffen, der Inhalt des Absatzes ist der Inhalt (Textwert) des
gerade aktuellen Datenknotens.</p>

<pre><code>&lt;Textblock breite=&quot;{$breite}&quot; schriftart=&quot;text&quot; textformat=&quot;Text mit Einrückung&quot;&gt;
  &lt;Absatz&gt;
    &lt;Wert auswahl=&quot;.&quot;/&gt;
  &lt;/Absatz&gt;
&lt;/Textblock&gt;
</code></pre>

<h2>Folgende XPath-Ausdrücke erkennt das System:</h2>

<ul>
<li>Zahl: gibt den Wert direkt zurück. Beispiel: <code>&quot;5&quot;</code></li>
<li>Text: gibt den Wert direkt zurück. Beispiel: <code>'Text'</code></li>
<li>Rechenoperationen (<code>*</code>, <code>div</code>, <code>idiv</code>, <code>+</code>, <code>-</code>, <code>mod</code>). Beispiel:
<code>( 6 + 4.5 ) * 2</code></li>
<li>Zugriff auf Variablen. Beispiel: <code>$spalte + 2</code></li>
<li>Zugriff auf den aktuellen Knoten (Punkt-Operator). Beispiel: <code>. + 2</code></li>
<li>Zugriff auf Unterelemente. Beispiel: <code>produktdaten</code>, <code>node()</code>, <code>*</code>, <code>foo/bar</code></li>
<li>Zugriff auf Attribute im aktuellen Knoten. Beispiel <code>@a</code></li>
<li>Zugriff auf Attribute in Kindelementen, zum Beispiel <code>foo/@bar</code>.</li>
<li>Boolesche Ausdrücke: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code>, <code>!=</code>. Vorsicht, das
Zeichen <code>&lt;</code> muss in XML als <code>&amp;lt;</code> geschrieben werden, das Zeichen
<code>&gt;</code> kann als <code>&amp;gt;</code> geschrieben werden. Beispiel: <code>$zahl &gt; 6</code>. Kann
in Bedingungen benutzt werden.</li>
<li>Einfache <code>if/then/else</code>-Abfragen: <code>if (...) then ... else ...</code></li>
</ul>

<h2>Folgende XPath-Funktionen stehen bereit:</h2>

<p>Es gibt zwei Klassen von XPath Funktionen: standardkonforme und speedata
Publisher spezifische Funktionen. Die spezifischen Funktionen sind im
Namensraum <code>urn:speedata:2009/publisher/functions/de</code> (im Folgenden mit
<code>sd:</code> gekennzeichnet). Die standard-Funktionen sollten sich wie XPath
2.0 verhalten.</p>

<table>
<thead>
<tr>
<th>Funktion</th>
<th>Beschreibung</th>
</tr>
</thead>

<tbody>
<tr>
<td>sd:aktuelle-rahmennummer(&lt;name&gt;)</td>
<td>Gibt die Nummer des aktuellen Rahmens im Platzierungsbereich zurück.</td>
</tr>

<tr>
<td>sd:aktuelle-seite()</td>
<td>Gibt die Seitennummer zurück.</td>
</tr>

<tr>
<td>sd:aktuelle-zeile(&lt;name&gt;)</td>
<td>Gibt die aktuelle Zeile zurück. Wenn <code>name</code> angegeben, gibt die Zeile des gegebenen Positionsrahmens zurück.</td>
</tr>

<tr>
<td>sd:aktuelle-spalte(&lt;name&gt;)</td>
<td>Gibt die aktuelle Spalte zurück. Wenn <code>name</code> angegeben, gibt die Spalte des gegebenen Positionsrahmens zurück.</td>
</tr>

<tr>
<td>sd:alternierend(&lt;typ&gt;, &lt;text&gt;,&lt;text&gt;,.. )</td>
<td>Bei jedem Aufruf wird das nächste Argument zurück gegeben. Wert des Typs ist beliebig, muss aber eindeutig sein. Beispiel: <code>sd:alternierend(&quot;tbl&quot;, &quot;Weiß&quot;,&quot;Grau&quot;)</code> könnte für die Hintergrundfarbe von Tabellen benutzt werden.</td>
</tr>

<tr>
<td>sd:alternierend-zurücksetzen(&lt;typ&gt;)</td>
<td>Setzt den Zustand für <code>sd:alternierend()</code> für den angegebenen Typ zurück.</td>
</tr>

<tr>
<td>sd:alternierend-beibehalten(&lt;typ&gt;)</td>
<td>Nutzt den aktuellen Wert von <code>sd:alternierend(&lt;typ&gt;)</code>, ohne diesen zu verändern.</td>
</tr>

<tr>
<td>sd:anzahl-gespeicherte-seiten(&lt;Name&gt;)</td>
<td>Gibt die Anzahl der gespeicherten Seiten, die mit &lt;SeitenSpeichern&gt; zwischengspeichert wurden.</td>
</tr>

<tr>
<td>sd:anzahl-datensätze(&lt;Sequenz&gt;)</td>
<td>Gibt die Anzahl der Datensätze der Sequenz zurück.</td>
</tr>

<tr>
<td>sd:anzahl-seiten(&lt;Dateiname oder URI-Schema&gt;)</td>
<td>Ermittelt die Anzahl der Seiten der angegebenen (PDF-)Datei.</td>
</tr>

<tr>
<td>sd:anzahl-spalten()</td>
<td>Gibt die Anzahl der Spalten im aktuellen Raster.</td>
</tr>

<tr>
<td>sd:anzahl-zeilen()</td>
<td>Gibt die Anzahl der Zeilen im aktuellen Raster.</td>
</tr>

<tr>
<td>sd:attr(&lt;Name&gt;, ...)</td>
<td>ist dasselbe wie <code>@Name</code>, nur mit der Möglichkeit den Namen auch dynamisch (z.B. mit <code>concat()</code>) zu erzeugen. Siehe Beispiel bei <code>sd:variable()</code>.</td>
</tr>

<tr>
<td>sd:belegt(x,y,&lt;Bereichsname&gt;,&lt;Rahmennummer&gt;)</td>
<td>Gibt wahr zurück, wenn die Zelle belegt ist (seit 2.3.71).</td>
</tr>

<tr>
<td>sd:bildbreite(&lt;Dateiname oder URI-Schema&gt;)</td>
<td>Breite des Bildes in Rasterzellen. Vorsicht: sollte das Bild nicht gefunden werden, wird die Breite des Platzhalters für nicht gefundene Bilder zurückgegeben. Daher muss vorher überprüft werden, ob das Bild existiert.</td>
</tr>

<tr>
<td>sd:bildhöhe(&lt;Dateiname oder URI-Schema&gt;)</td>
<td>Höhe des Bildes in Rasterzellen. Vorsicht: sollte das Bild nicht gefunden werden, wird die Höhe des Platzhalters für nicht gefundene Bilder zurückgegeben. Daher muss vorher überprüft werden, ob das Bild existiert.</td>
</tr>

<tr>
<td>sd:datei-vorhanden(&lt;Dateiname oder URI-Schema&gt;)</td>
<td>Wahr, wenn der Dateiname im Suchpfad existiert, ansonsten false.</td>
</tr>

<tr>
<td>sd:formatiere-zahl(Zahl oder String, Tausenderzeichen, Kommazeichen)</td>
<td>Formatiert die übergebene Zahl und fügt Tausender-Trennzeichen hinzu und ändert den Kommatrenner. Beispiel: <code>sd:formatiere-zahl(12345.67, '.',',')</code> ergibt die Zeichenkette <code>1.2345,67</code>.</td>
</tr>

<tr>
<td>sd:formatiere-string(Objekt,Objekt,...,Formartierungsangaben)</td>
<td>Gibt eine Zeichenkette zurück, die die gegebenen Objekte mit den im zweiten Argument gegebenen Formatierungsanweisungen darstellt. Die Formatierungsanweisungen entsprechen der aus der Programmiersprache C bekannten <code>printf()</code>-Funktion.</td>
</tr>

<tr>
<td>sd:gerade(&lt;zahl&gt;)</td>
<td>Wahr, wenn die angegebene Zahl gerade ist. Beispiel: <code>sd:gerade(sd:aktuelle-seite())</code></td>
</tr>

<tr>
<td>sd:html-dekodieren(&lt;Node&gt;)</td>
<td>Wandelt Texte wie <code>&amp;lt;i&amp;gt;Kursiv&amp;lt;/i&amp;gt;</code> in entsprechendes HTML-Markup.</td>
</tr>

<tr>
<td>sd:ungerade(&lt;zahl&gt;)</td>
<td>Wahr, wenn die angegebene Zahl ungerade ist.</td>
</tr>

<tr>
<td>sd:gruppenbreite(&lt;string&gt;)</td>
<td>Gibt die Breite in Rasterzellen für die Gruppe im ersten Argument an. Beispiel: <code>sd:gruppenbreite('Beispielgruppe')</code></td>
</tr>

<tr>
<td>sd:gruppenhöhe(&lt;string&gt;)</td>
<td>Gibt die Höhe in Rasterzellen für die Gruppe im ersten Argument an. Beispiel: <code>sd:gruppenbreite('Beispielgruppe')</code></td>
</tr>

<tr>
<td>sd:seitennummer(&lt;Marke&gt;)</td>
<td>Liefert die Seitenzahl der Seite auf der die angegebene Marke ausgegeben wurde. Siehe den Befehl <a href="../commands-de/mark.html">Marke</a></td>
</tr>

<tr>
<td>sd:seitenverhältnis(&lt;Bildname&gt;)</td>
<td>Gibt das Ergebnis der Divsion Bildbreite / Bildhöhe zurück. (D.h. &lt; 1 für Hochkantbilder, &gt; 1 für Querformat.)</td>
</tr>

<tr>
<td>sd:seitenzahlen-zusammenfassen(&lt;Seitenzahlen&gt;,&lt;Trenner für Bereiche&gt;,&lt;Trenner für Leerraum&gt;)</td>
<td>Fasst Seitenzahlenbereiche zusammen. Beispielsweise aus <code>&quot;1, 3, 4, 5&quot;</code> wird <code>1, 3–5</code>. Voreinstellung für den Trenner für Bereiche ist ein Halbgeviertstrich (–), Voreinstellung für den Trenner für Leerraum ist ', ' (Komma, Leerzeichen). Diese Funktion sortiert die Zahlen und löscht doppelte Einträge. Bei leerem Trenner für Bereiche werden Zahlen nicht zusammengeführt, sondern einzeln mit dem Trenner für Leerraum verbunden.</td>
</tr>

<tr>
<td>sd:sha1(&lt;Wert&gt;,&lt;Wert&gt;, …)</td>
<td>Erzeugt die SHA-1 Summe der Hintereinanderkettung der Werte als Hex-Zeichenkette. Beispiel: <code>sd:sha1('Hallo ', 'Welt')</code> ergibt die Zeichenkette <code>28cbbc72d6a52617a7abbfff6756d04bbad0106a</code>.</td>
</tr>

<tr>
<td>sd:variable(&lt;Name&gt;, ...)</td>
<td>ist dasselbe wie $Name, nur mit der Möglichkeit den Namen auch dynamisch zu erzeugen. Falls <code>$i</code> den Wert 3 enthält, liest <code>sd:variable('foo',$i)</code> den Inhalt der Variablen <code>$foo3</code>. Damit lassen sich Arrays abbilden.</td>
</tr>

<tr>
<td>sd:variable-vorhanden(&lt;Name&gt;)</td>
<td>Prüft, ob eine Variable vorhanden ist.</td>
</tr>

<tr>
<td>sd:blindtext()</td>
<td>Gibt den Blindtext &quot;Lorem ipsum...&quot; mit über 50 Wörtern zurück.</td>
</tr>

<tr>
<td>sd:loremipsum()</td>
<td>Alias für <code>sd:blindtext()</code></td>
</tr>

<tr>
<td>sd:zufallswert(&lt;Wert&gt;,&lt;Wert&gt;, …)</td>
<td>Gibt einen der Werte zurück.</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Funktion</th>
<th>Beschreibung</th>
</tr>
</thead>

<tbody>
<tr>
<td>abs()</td>
<td></td>
</tr>

<tr>
<td>ceiling()</td>
<td></td>
</tr>

<tr>
<td>concat( &lt;Wert&gt;,&lt;Wert&gt;, … )</td>
<td>Erzeugt einen neuen Text aus der Verkettung der einzelnen Werte.</td>
</tr>

<tr>
<td>contains(&lt;heuhaufen&gt;,&lt;nadel&gt;)</td>
<td>Wahr, wenn <code>heuhaufen</code> <code>nadel</code> enthält.</td>
</tr>

<tr>
<td>count()</td>
<td>Zählt alle Kindelemente mit dem angegebenen Namen. Beispiel: <code>count(eintrag)</code> zählt, wie viele Kindelemente mit den Namen <code>eintrag</code> existieren.</td>
</tr>

<tr>
<td>ceiling()</td>
<td>Gibt den aufgerundeten Wert einer Zahl zurück.</td>
</tr>

<tr>
<td>empty(&lt;Attribut&gt;)</td>
<td>Prüft, ob ein Attribut (nicht) vorhanden ist.</td>
</tr>

<tr>
<td>false()</td>
<td>Gibt „Falsch“ zurück.</td>
</tr>

<tr>
<td>floor()</td>
<td>Gibt den abgerundeten Wert einer Zahl zurück.</td>
</tr>

<tr>
<td>last()</td>
<td>Gibt die Anzahl der Datensätze der gleichnamigen Geschwister-Elemente zurück. <strong>Achtung: noch nicht XPath-konform.</strong></td>
</tr>

<tr>
<td>normalize-space(&lt;text&gt;)</td>
<td>Gibt den Text ohne führende und nachstehende Leerzeichen zurück. Alle Zeilenvorschübe werden durch Leerzeichen ersetzt. Mehrfach hintereinander auftretende Leerzeichen/Zeilenvorschübe werden durch ein einzelnes Leerzeichen ersetzt.</td>
</tr>

<tr>
<td>max()</td>
<td></td>
</tr>

<tr>
<td>min()</td>
<td></td>
</tr>

<tr>
<td>node()</td>
<td></td>
</tr>

<tr>
<td>not()</td>
<td>Negiert den Wahrheitswert des Arguments. Beispiel: <code>not(true())</code> ergibt <code>false()</code>.</td>
</tr>

<tr>
<td>position()</td>
<td>Ermittelt die Position des aktuellen Datensatzes.</td>
</tr>

<tr>
<td>replace(&lt;Eingabe&gt;,&lt;Regexp&gt;, &lt;Ersetzung&gt;)</td>
<td>Ersetzt die Eingabe mit dem regulären Ausdruck durch den Ersetzungstext. Beispiel: <code>replace(&quot;banana&quot;, &quot;a&quot;, &quot;o&quot;)</code> ergibt <code>bonono</code>.</td>
</tr>

<tr>
<td>string(&lt;Sequenz&gt;)</td>
<td>Gibt den Textwert der Sequenz zurück, d.h. den Inhalt der Elemente.</td>
</tr>

<tr>
<td>string-join(&lt;Sequenz&gt;, Separator)</td>
<td>Gibt den Textwert der Sequenz zurück, wobei alle Elemente durch den Separator getrennt werden.</td>
</tr>

<tr>
<td>string-length(&lt;string&gt;)</td>
<td>Gibt die Länge der Zeichenkette zurück. Multi-byte UTF-8 Sequenzen werden als eine Position gezählt.</td>
</tr>

<tr>
<td>substring(&lt;input&gt;,&lt;start&gt;,&lt;length&gt;)</td>
<td>Gibt einen Teil der Zeichenkette aus <code>input</code> zurück, die bei <code>start</code> anfängt und (optional) die Länge <code>length</code> hat.</td>
</tr>

<tr>
<td>true()</td>
<td>Gibt „Wahr“ zurück.</td>
</tr>

<tr>
<td>tokenize(&lt;Eingabe&gt;,&lt;Regexp&gt;)</td>
<td>Die Rückgabe ist eine Sequenz von Zeichenketten. Die Eingabe wird von links nach rechts gelesen. Sobald eine Stelle gefunden wird, auf die der Reguläre Ausdruck passt, wird die bisherige Eingabe zurück gegeben. Beispiel (aus M. Kays XPath / XSLT-Buch): <code>tokenize(&quot;Go home, Jack!&quot;, &quot;\W+&quot;)</code> ergibt die Sequenz <code>&quot;Go&quot;, &quot;home&quot;, &quot;Jack&quot;, &quot;&quot;</code>.</td>
</tr>

<tr>
<td>upper-case()</td>
<td></td>
</tr>
</tbody>
</table>

</div>


<div style="clear:both; border-bottom: 1px solid #a0a0a0; width: 100%; margin-top: 30px;"></div>
Version: 2.5.1 | <a href="../index-de.html">Startseite</a> | <a href="../commands-de/layout.html">Elementreferenz</a> | Andere Sprache:  <a href="../description-en/xpath.html">Englisch</a>

</body>
</html>