<!DOCTYPE html>
<html>
<head>
    <title>Pre-processing with a Lua filter</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link rel="alternate" type="application/atom+xml"  title="changelog speedata Publisher (en)"  href="../changes-en.xml" />
    <link rel="stylesheet" href="../assets/css/normal.css" type="text/css" />
    <link rel="stylesheet" href="../assets/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../assets/css/colorbox.css" type="text/css" />
    <script src="../assets/js/jquery.min.js" ></script>
    <script src="../assets/js/jquery.colorbox-min.js" ></script>
    <script>
      $(document).ready(function(){
         $(".figure").colorbox({ rel: 'group1', opacity:0.5 });
      });
    </script>
</head>
<body>
<div id="logo"><a href="../index.html"><img src="../assets/images/publisher_logo.png" alt="Start page"></a></div>
<div class="">
<p>The ability to run a Lua script before the publishing run is available since version 3.1.9.</p>

<p>The command line/configuration interface is the same as for the XProc filter:</p>

<pre><code>sp --filter myfile.lua
</code></pre>

<p>or</p>

<pre><code>filter=myfile.lua
</code></pre>

<p>The Lua script is run before any rendering gets done, so the main application is probably the transformation of input data into a format that is suitable for the speedata Publisher.</p>

<p>You can use anything that is allowed in Lua.
Additionally the publisher provides the modules <code>csv,</code>runtime<code>and</code>xml` which contain the following entries:</p>

<p><strong>Note</strong>: the API is subject to change!</p>

<h2>csv</h2>

<p><code>csv.decode(filename,parameter)</code>: loads a CSV (comma separated values) file and returns (first argument) the boolean success. If true, the second return value contains the table, if false, the second return value contains an error message (string). The value parameter is an optional table which controls the CSV input and output. You can provide the following values:</p>

<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>charset</td>
<td>If the CSV file is encoded in Latin-1, you have to set this to the value <code>ISO-8859-1</code>. Ask us for more character sets.</td>
</tr>

<tr>
<td>separator</td>
<td>The value of the field separator. Defaults to a comma, but can be any character.</td>
</tr>

<tr>
<td>columns</td>
<td>A table that has the required columns in the given order. For example <code>{3,2,1}</code> limits the output to the first three columns in reverse order.</td>
</tr>
</tbody>
</table>

<p>Example:</p>

<pre><code>csv.decode(&quot;myfile.csv&quot;, { charset = &quot;ISO-8859-1&quot;, separator = &quot;;&quot;, columns = {1,2,5} })
</code></pre>

<p>The table has at index 1..n the rows of the CSV file and each rows is a table in which the index 1..m is each table cell.</p>

<h2>runtime</h2>

<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>projectdir</code></td>
<td>A value that contains the current working directory (the one with the <code>layout.xml</code> and <code>publisher.cfg</code>)</td>
</tr>

<tr>
<td><code>run_saxon</code></td>
<td>A function that calls the external Java-program <code>saxon</code>. It accepts three mandatory arguments (the transformation stylesheet, the input file and the output file) and an optional argument that is passed as the parameter string to saxon. The function returns a boolean value (success) and optionally a string in case of a <code>false</code> success value.</td>
</tr>

<tr>
<td><code>validate_relaxng</code></td>
<td>A function that validates an XML file against a RelaxNG schema. The first argument is the XML file, the second argument the RelaxNG schema. You can use relative paths for both.</td>
</tr>
</tbody>
</table>

<pre><code>ok, err = runtime.run_saxon(&quot;transformation.xsl&quot;,&quot;source.xml&quot;,&quot;data.xml&quot;,&quot;param1=value1 param2=value2&quot;)

-- stop the publishing process if an error occurs
if not ok then
    print(err)
    os.exit(-1)
end
</code></pre>

<p>Validation:</p>

<pre><code>ok, msg = runtime.validate_relaxng(&quot;layout.xml&quot;,&quot;../schema/layoutschema-de.rng&quot;)
if not ok then
    print(msg)
    os.exit(-1)
end
</code></pre>

<h2>xml</h2>

<p><code>xml.encode_table(table)</code>: Create an XML file from a table. It returns (first argument) the boolean “success”. If false, the second return value contains an error message (string).</p>

<p>The table has the following structure</p>

<p>A comment has the form</p>

<pre><code>comment = {
         _type = &quot;comment&quot;,
         _value = &quot;This is a comment!&quot;
   }
</code></pre>

<p>and an element:</p>

<pre><code>element = {
    [&quot;_type&quot;] = &quot;element&quot;,
    [&quot;_name&quot;] = &quot;root&quot;,
    attribute1 = &quot;value1&quot;,
    attribute2 = &quot;value2&quot;,
    child1,
    child2,
    child3,
    ...
}
</code></pre>

<p><code>child1</code>, ... are strings, elements or comments.</p>

<p>The XML file gets written with the name <code>data.xml</code></p>

<h2>xlsx</h2>

<p><code>open(filename)</code>: loads the given Excel file (file extension <code>.xlsx</code>) and in case of success returns an object which can be used to access the contents of the spreadsheet. In case of an error it returns two arguments. The first argument is <code>false</code> and the second argument contains the error message.</p>

<p>Usage:</p>

<pre><code>spreadsheet, err = xlsx.open(&quot;myfile.xlsx&quot;)
if not spreadsheet then
    print(err)
    os.exit(-1)
end
</code></pre>

<p>The object <code>spreadsheet</code> contains the worksheets. The number of worksheets can be obtained by the length operator (#) and each worksheet is indexed stating from one:</p>

<pre><code>numWorksheets = #spreadsheet
ws = spreadsheet[1]
</code></pre>

<p>The object <code>ws</code> can be used to get the contents of each cell.
Use the object as a function call with the coordinates as the arguments.
It returns the cell contents as a string.
The top left cell has the coordinate (1,1), the first cell in the second row (1,2) and so on.</p>

<pre><code>cell1 = ws(1,1)
cell2 = ws(1,2)
</code></pre>

<p>Some properties can be queried in the worksheet object:</p>

<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>minrow</td>
<td>First row that contains data</td>
</tr>

<tr>
<td>maxrow</td>
<td>Last row that contains data</td>
</tr>

<tr>
<td>mincol</td>
<td>First column that contains data</td>
</tr>

<tr>
<td>maxcol</td>
<td>Last column that contains data</td>
</tr>

<tr>
<td>name</td>
<td>Name of the worksheet</td>
</tr>
</tbody>
</table>

</div>


<div style="clear:both; border-bottom: 1px solid #a0a0a0; width: 100%; margin-top: 30px;"></div>
Version: 3.1.19 | <a href="../index.html">Start page</a> | <a href="../commands-en/layout.html">Element reference</a> | Other language:  <a href="../description-de/luafilter.html">German</a>

</body>
</html>